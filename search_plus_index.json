{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Java 核心技术 数据结构与算法 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树。10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 By Ace            此页面修订于： 2019-06-19 10:37:54 "},"Java核心技术/Java基础.html":{"url":"Java核心技术/Java基础.html","title":"Java 基础","keywords":"","body":"Java 基础 Exception 和 Error 的区别 都继承了 Throwable 类，可以被抛出（throw）和捕获（catch）。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error 是指正常情况下，不大可能出现的情况，所以不便于也不需要被捕获。 尽量不用捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。不要生吞异常。 final、finally、finalize final 不等同于 immutable，final List strList = new ArrayList<>() final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。 需要关闭的连接等资源，更推荐使用 Java 7 中添加的 try-with-resources 语句，通常 Java 平台能够更好地处理异常情况，编码量也要少很多。 finalize 被设计为在对象被垃圾收集前调用。现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。 强引用、软引用、弱引用、幻想引用 不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。 强引用：普通对象引用，只有超过了引用的作用域或者显示地将相应的强引用赋值为 null ，就是可以被垃圾收集了。 软引用：可以让对象豁免一些垃圾回收，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。可用于实现内存敏感的缓存。 弱引用：不能使对象豁免垃圾收集，可以用来构建一种没有特定约束的关系。 幻想引用：提供一种确保对象被 finalize 以后，做某些事情的机制。 int 和 Integer Java 5 中新增了静态工厂方法 valueOf，利用一个值缓存机子，-128 ~ 127。 自动装箱、拆箱，算是一种语法糖，发生在编译阶段，生成的字节码是一致的。 By Ace            此页面修订于： 2019-06-19 10:37:54 "},"Java核心技术/Java并发编程.html":{"url":"Java核心技术/Java并发编程.html","title":"Java 并发编程","keywords":"","body":"并发Bug的源头 核心矛盾在于CPU、内存、I/O设备的速度差异。为了合理利用CPU的高性能，平衡三者的速度差异： CPU 增加了缓存，以均衡与内存的速度差异； 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异； 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。 源头之一：缓存导致的可见性问题 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。 线程A对变量V的操作对于线程B而言就不具备可见性。 源头之二：线程切换带来的原子性问题 我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性。 高级语言里的一条语句往往需要多条CPU指令完成，例如 count += 1，至少需要三条CPU指令。 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器； 指令 2：之后，在寄存器中执行 +1 操作； 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。 而操作系统做任务切换，可以发生在任何一条CPU指令执行完，而不是高级语言里的一条语句。 源头之三：编译优化带来的有序性问题 双重检查创建单例对象案例： public class Singleton { static Singleton instance; static Singleton getInstance(){ if (instance == null) { synchronized(Singleton.class) { if (instance == null) instance = new Singleton(); } } return instance; } } 假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。 我们以为的new操作应该是： 分配一块内存 M； 在内存 M 上初始化 Singleton 对象； 然后 M 的地址赋值给 instance 变量。 但是实际上优化后的执行路径却是这样的： 分配一块内存 M； 将 M 的地址赋值给 instance 变量； 最后在内存 M 上初始化 Singleton 对象。 解决可见性和有序性问题 导致可见性的原因是缓存，导致有序性的原因是编译优化，所以最直接的办法就是禁用缓存和编译优化（程序性能就堪忧了）。合理的方案是按需禁用缓存以及编译优化。 volatile 最原始的意义就是禁用CPU缓存。 Happens-Before 规则 前面一个操作的结果对后续操作是可见的。 在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。 对于一个 volatile 变量的写操作，Happens-Before 于后续对这个 volatile 变量的读操作。 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。 “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。 根据规则 3 的内容，如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。 对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。 主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。或者说，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。 主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。或者说，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。 final final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。 解决原子性问题 原子性问题的源头是线程切换。 synchronize 当修饰静态方法时，锁定的是当前类的 Class 对象； 当修饰非静态方法的时候，锁定的是当前实例对象 this。 class X { // 修饰静态方法 synchronized(X.class) static void bar() { // 临界区 } } class X { // 修饰非静态方法 synchronized(this) void foo() { // 临界区 } } 锁和受保护资源的关系：受保护资源和锁之间的关联关系是 N:1 的关系。 class SafeCalc { static long value = 0L; synchronized long get() { return value; } synchronized static void addOne() { value += 1; } } class Account { private int balance; // 转账 synchronized void transfer( Account target, int amt){ if (this.balance > amt) { this.balance -= amt; target.balance += amt; } } } 看似正确，但是 this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance。 死锁 细粒度锁：用不同的锁对受保护资源进行精细化管理，能够提升性能。但是使用细粒度锁是有代价的，这个代价就是可能会导致死锁。 死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。解决死锁最好的办法还是规避死锁。 只有以下四个条件都发生时才会出现死锁： 互斥，共享资源 X 和 Y 只能被一个线程占用； 占用且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X； 不可抢占，其他线程不能强行抢占线程 T1 占用的资源； 循环等待，线程 T1 等待线程 T2 占用的资源，线程 T2 等待线程 T1 占用的资源，就是循环等待。 只要破坏其中一个，就可以成功避免死锁的发生。 互斥这个条件我们没法破坏，因为我们用锁为的就是互斥。 1.破坏占用且等待条件 理论上要破坏这个条件，可以一次性申请所有资源。等待-通知机制： 如果线程要求的条件不满足，则线程阻塞自己，进入等待状态；当线程要求的条件满足后，通知等待的线程重新执行。wait(), notify(), notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait(), this.notify(), this.notifyAll()。尽量使用 notifyAll()，notify() 是会随机地通知等待队列中的一个线程（风险在于可能导致某些线程永远不会被通知到），而 notifyAll() 会通知等待队列中的所有线程。 2.破坏不可抢占条件 核心就是要能够主动释放它占有的资源。这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。 3.破坏循环等待条件 破坏这个条件，需要对资源进行排序，然后按序申请资源。 By Ace            此页面修订于： 2019-06-19 10:52:31 "},"Java核心技术/并发/Java生命周期.html":{"url":"Java核心技术/并发/Java生命周期.html","title":"Java生命周期","keywords":"","body":"Java语言中线程共用六种状态，分别是： NEW（初始化状态） RUNNABLE （可运行/运行状态） BLOCKED （阻塞状态） WAITING （无时限等待） TIMED_WAITING （有时限等待） TERMINATED （终止状态） 1、RUNNABLE 与 BLOCKED 的状态转换 只有一种情况会触发，就是线程等待和获取 synchronized 的隐式锁。 2、RUNNABLE 与 WAITING 的状态转换 获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 调用无参数的 Thread.join() 方法，等待中的线程其状态会从 RUNNABLE 转换到 WAITING 调用 LockSupport.park() 3、RUNNABLE 与 TIMED_WAITING 的状态转换 五种场景方法： Thread.sleep(long millis)Object.wait(long timeout)Thread.join(long millis)LockSupport.parkNanos(Object blocker, long deadline)LockSupport.parkUntil(long deadline) 4、从 NEW 到 RUNNABLE 通过 Thread.start() 实现 By Ace            此页面修订于： 2019-06-19 10:56:57 "},"Java核心技术/并发/并发工具类.html":{"url":"Java核心技术/并发/并发工具类.html","title":"并发工具类","keywords":"","body":"Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。 用锁的最佳实践： 永远只在更新对象的成员变量时加锁； 永远只在访问可变的成员变量时加锁； 永远不在调用其他对象的方法时加锁。 Lock Lock 有别于 synchronized 隐式锁的三个特性： 能够响应中断； 支持超时 - 如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误； 非阻塞地获取锁 - 如果尝试获取锁失败，并不进入阻塞状态，而是直接返回。 // 支持中断的 API void lockInterruptibly() throws InterruptedException; // 支持超时的 API boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 支持非阻塞获取锁的 API boolean tryLock(); Condition 线程等待和通知需要调用 await()、asignal()、asignalAll()参考 Dubbo 源码 DefaultFuture.get ReadWriteLock 针对读多写少的并发场景 允许多个线程同时读共享变量； 只允许一个线程写共享变量； 如果一个写线程正在执行写操作，此时禁止读线程读取共享变量。 ReadWriteLock 不支持锁升级，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒。但是从写锁到读锁的锁的降级是被允许的。 class CachedData { Object data; volatile boolean cacheValid; final ReadWriteLock rwl = new ReentrantReadWriteLock(); // 读锁 final Lock r = rwl.readLock(); // 写锁 final Lock w = rwl.writeLock(); void processCachedData() { // 获取读锁 r.lock(); if (!cacheValid) { // 释放读锁，因为不允许读锁的升级 r.unlock(); // 获取写锁 w.lock(); try { // 再次检查状态 if (!cacheValid) { data = ... cacheValid = true; } // 释放写锁前，降级为读锁 // 降级是可以的 r.lock(); } finally { // 释放写锁 w.unlock(); } } // 此处仍然持有读锁 try {use(data);} finally {r.unlock();} } } 只有写锁支持条件变量，读锁调用 newCondition() 会抛出 UnsupportedOperationException 异常。 StampedLock ReadWriteLock 支持两种锁：读锁和写锁；StampedLock 支持三种锁：写锁、悲观读锁和乐观读。 允许多个线程同时获取悲观读锁，但只允许一个线程获取写锁，和 ReadWriteLock 的读写锁非常类似。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。 final StampedLock sl = new StampedLock(); // 获取 / 释放悲观读锁示意代码 long stamp = sl.readLock(); try { // 省略业务相关代码 } finally { sl.unlockRead(stamp); } // 获取 / 释放写锁示意代码 long stamp = sl.writeLock(); try { // 省略业务相关代码 } finally { sl.unlockWrite(stamp); } StampedLock 的性能之所以比 ReadWriteLock 好的原因在于，StampedLock 支持乐观读，在多线程同时读的时候，允许一个线程获取写锁，乐观读这个操作是无锁的。 StampedLock 使用注意事项： StampedLock 不支持重入；StampedLock 的悲观读锁、写锁都不支持条件变量；如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。 final StampedLock lock = new StampedLock(); Thread T1 = new Thread(()->{ // 获取写锁 lock.writeLock(); // 永远阻塞在此处，不释放写锁 LockSupport.park(); }); T1.start(); // 保证 T1 获取写锁 Thread.sleep(100); Thread T2 = new Thread(()-> // 阻塞在悲观读锁 lock.readLock() ); T2.start(); // 保证 T2 阻塞在读锁 Thread.sleep(100); // 中断线程 T2 // 会导致线程 T2 所在 CPU 飙升 T2.interrupt(); T2.join(); 使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。 By Ace            此页面修订于： 2019-06-19 18:12:03 "},"数据结构与算法/复杂度分析.html":{"url":"数据结构与算法/复杂度分析.html","title":"复杂度分析","keywords":"","body":"复杂度分析 时间复杂度 T(n): 代码执行的时间 n: 数据规模的大小 f(n): 每行代码执行的次数总和 O: 代码的执行时间T(n)与f(n)表达式成正比 大 O 时间复杂度表示法表示代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度，简称时间复杂度。 n 很大时，可以忽略低价、常量和系数。 只关注循环执行次数最多的一段代码。 加分法则：总复杂度等于量级最大的那段代码的复杂度。 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。 By Ace            此页面修订于： 2019-06-19 10:37:54 "},"数据结构与算法/数组与链表.html":{"url":"数据结构与算法/数组与链表.html","title":"数组与链表","keywords":"","body":"数组与链表 写链表代码： 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。 利用哨兵简化实现难度 重点留意边界条件处理如果链表为空时如果链表只包含一个节点时如果链表只包含两个节点时代码逻辑在处理头节点和尾结点的时候 举例画图，辅助思考 By Ace            此页面修订于： 2019-06-19 10:37:54 "},"数据库/数据库安装.html":{"url":"数据库/数据库安装.html","title":"数据库","keywords":"","body":"Linux 安装 MySQL 官网下载 登录官网 https://dev.mysql.com/downloads/mysql/ 选择Linux操作系统，5.7.26版本 下载64位安装包 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz 安装 解压移动到相应路径 tar zxvf mysql-5.7.26-linux-glibc2.12-x86_64.tar.gzmv mysql-5.7.26-linux-glibc2.12-x86_64 /usr/local/server/mysql-5.7.26 添加mysql用户和用户组 groupadd mysqluseradd -r -g mysql mysql 更新mysql目录权限 cd /usr/local/server/mysql-5.7.26chown -R mysql. ./ 创建mysql数据存储目录 mkdir /data/local/mysqlmkdir /data/local/mysql/databasechown -R mysql. /data/local/mysql/ 修改/etc/my.cnf [mysqld] basedir=/usr/local/server/mysql-5.7.26 datadir=/data/local/mysql/database socket=/data/local/mysql/mysql.sock log_bin=/data/local/mysql/mysql-bin port=4306 server-id=1 lower_case_table_names=1 default-storage-engine=INNODB character-set-server=utf8 collation-server=utf8_general_ci symbolic-links=0 log-error=/var/log/mysql/mysql.log pid-file=/var/run/mysql/mysql.pid [mysqld_safe] log-error=/var/log/mysql/mysql.log pid-file=/var/run/mysql/mysql.pid # # include all files from the config directory # !includedir /etc/my.cnf.d 数据库初始化 yum install libaio/usr/local/server/mysql-5.7.26/bin/mysqld --initialize --user=mysql 注意生成临时root密码 初始化日志目录和pid目录 mkdir /var/log/mysqlchown -R mysql. /var/log/mysqlmkdir /var/run/mysqlchown -R mysql. /var/run/mysql 启动mysql /usr/local/server/mysql-5.7.26/support-files/mysql.server start 添加service服务和开机自启动 cp .support-files/mysql.server /etc/init.d/mysqldchkconfig --add mysqldchkconfig --list 添加系统路径 vim /etc/profile export MYSQL_HOME=/usr/local/server/mysql-5.7.26 export PATH=$PATH:$MYSQL_HOME/bin source /etc/profile 运行 登录mysql 在/etc/my.cnf中添加 [client] socket=/data/local/mysql/mysql.sock 重置密码 set password=password('新密码'); 增加远程登录权限 use mysql; select user, host from user; update user set host='%' where user='root'; flush privileges; By Ace            此页面修订于： 2019-06-19 10:37:54 "},"运维/dubbo.html":{"url":"运维/dubbo.html","title":"Dubbo","keywords":"","body":"Dubbo Apache Dubbo 服务注册 Nacos POM 配置 2.7.1 1.0.0 org.apache.dubbo dubbo ${dubbo.version} org.apache.dubbo dubbo-spring-boot-starter ${dubbo.version} org.apache.dubbo dubbo-registry-nacos ${dubbo.version} com.alibaba.nacos nacos-client ${nacos.client.version} application.yml 配置 # dubbo 配置 dubbo: application: name: soa-provider protocol: name: dubbo port: 10022 registry: address: nacos://ip1:8848,ip2:8848,ip3:8848 provider: group: local BootStrap 配置 @SpringBootApplication @ComponentScan(\"com.tv\") @EnableDubbo(scanBasePackages = \"com.tv.soa.api.impl\") public class SoaProviderApplication { public static void main(String[] args) { SpringApplication.run(SoaProviderApplication.class, args); } } Alibaba Dubbo 服务注册 Nacos POM 配置 引入spring-boot-starter-web，没有web环境dubbo在spring启动后自动shutdown org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-logging org.springframework.boot spring-boot-starter-web com.alibaba dubbo-registry-nacos 0.0.1 com.alibaba dubbo 2.6.5 com.alibaba.spring spring-context-support 1.0.2 io.netty netty-all 4.1.34.Final application.yml 配置 多地址第一个后面以?分隔，其他同上 # dubbo 配置 dubbo: application: name: soa-provider protocol: name: dubbo port: 10022 registry: address: nacos://ip1:8848?ip2:8848,ip3:8848 provider: group: local By Ace            此页面修订于： 2019-06-19 10:37:54 "},"运维/nacos.html":{"url":"运维/nacos.html","title":"Nacos","keywords":"","body":"Nacos Nacos 集群安装 Github下载 wget https://github.com/alibaba/nacos/releases/download/1.0.0/nacos-server-1.0.0.tar.gz 解压安装 tar zxvf nacos-server-1.0.0.tar.gz cp -R nacos /usr/local/server/nacos-server-1.0.0 配置集群配置文件 vim conf/cluster.conf #it is ip #example 172.18.1.152:8848 172.18.1.153:8848 172.18.1.154:8848 配置mysql数据库 create database nacos_config default character set utf8 collate utf8_bin; 执行sql脚本 grant all on nacos_config.* to 'nacos'@'%' identified by 'nacos2019'; flush privileges; application.properties 配置数据库链接 vi application.properties # spring server.contextPath=/ server.servlet.contextPath=/ server.port=8848 db.num=1 db.url.0=jdbc:mysql://172.18.156.16:4306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true db.user=nacos db.password=nacos2019 nacos.cmdb.dumpTaskInterval=3600 nacos.cmdb.eventTaskInterval=10 nacos.cmdb.labelTaskInterval=300 nacos.cmdb.loadDataAtStart=false # metrics for prometheus #management.endpoints.web.exposure.include=* # metrics for elastic search management.metrics.export.elastic.enabled=false #management.metrics.export.elastic.host=http://localhost:9200 # metrics for influx management.metrics.export.influx.enabled=false #management.metrics.export.influx.db=springboot #management.metrics.export.influx.uri=http://localhost:8086 #management.metrics.export.influx.auto-create-db=true #management.metrics.export.influx.consistency=one #management.metrics.export.influx.compressed=true server.tomcat.accesslog.enabled=true server.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D %{User-Agent}i # default current work dir server.tomcat.basedir= ## spring security config ### turn off security #spring.security.enabled=false #management.security=false #security.basic.enabled=false #nacos.security.ignore.urls=/** nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/con sole/server/** nacos.naming.distro.taskDispatchThreadCount=1 nacos.naming.distro.taskDispatchPeriod=200 nacos.naming.distro.batchSyncKeyCount=1000 nacos.naming.distro.initDataRatio=0.9 nacos.naming.distro.syncRetryDelay=5000 nacos.naming.data.warmup=true nacos.naming.expireInstance=true 启动服务 bin/startup.sh 配置nginx upstream nacos-server { server 172.18.1.152:8848; server 172.18.1.153:8848; server 172.18.1.154:8848; } server { listen 80; server_name nacos.ice-leaf.com; location / { proxy_pass http://nacos-server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwared-For $proxy_add_x_forwarded_for; } } By Ace            此页面修订于： 2019-06-19 10:37:54 "},"运维/springboot-admin.html":{"url":"运维/springboot-admin.html","title":"SpringBootAdmin","keywords":"","body":"Spring Boot Admin SpringBoot Admin Server 新建项目 修正 pom.xml 4.0.0 org.springframework.boot spring-boot-starter-parent 2.1.4.RELEASE com.ice-leaf springboot-admin-server 1.0.0 spring-boot-admin-server Spring Boot Admin Server Project for Spring Boot 1.8 2.1.4 de.codecentric spring-boot-admin-starter-server org.springframework.boot spring-boot-starter-test test de.codecentric spring-boot-admin-dependencies ${spring-boot-admin.version} pom import org.springframework.boot spring-boot-maven-plugin 添加 @EnableAdminServer @EnableAdminServer @SpringBootApplication public class SpringbootAdminApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAdminApplication.class, args); } } 添加 application.yml management: endpoint: health: show-details: always endpoints: web: exposure: include: '*' SpringBoot Admin Client 添加 pom.xml de.codecentric spring-boot-admin-starter-client 2.1.4 添加 application.yml # springboot admin server spring: boot: admin: client: url: http://springboot-admin.ice-leaf.com instance: name: dev-soa-provider service-url: By Ace            此页面修订于： 2019-06-19 10:37:54 "}}