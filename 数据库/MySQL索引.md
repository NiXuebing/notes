# 索引

## 索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。  

主键索引（聚簇索引）：叶子节点存放整行数据。

非主键索引：叶子节点的内容是主键的值。  

非主键索引查询过程：先查询都主键值，再根据主键索引查到数据，即回表。



**因此，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**



自增主键的好处：每次插入一条新记录，都是追加操作，不会触发 B+ 树叶子节点的分裂。  



## 覆盖索引

索引内容满足查询要求，不需要回表，可以减少树的搜索次数，显著提升查询性能。



## 最左前缀原则

**联合索引的最左N个字段，或字符串索引的最左N个字符。**  

因此，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。



索引下推优化：在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



# 锁

## 全局锁

Flush tables with read lock （FTWRL）



## 表锁

lock tables ... read/write 



## 元数据锁 MDL

metedata lock 不需要显示使用，在访问一个表的时候会被自动加上。当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

- 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查；
- 读写锁之间，写锁之间互斥，用来保证变更表结构操作的安全性。



## 行锁

在 InnoDB 事务中，行锁是在需要的时候才加上，但并不是不需要了就立即释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。  

因此，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。





